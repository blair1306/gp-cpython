<dec f='codebrowser/Include/longobject.h' l='140' type='PyObject * _PyLong_FromByteArray(const unsigned char * bytes, size_t n, int little_endian, int is_signed)'/>
<doc f='codebrowser/Include/longobject.h' l='127'>/* _PyLong_FromByteArray:  View the n unsigned bytes as a binary integer in
   base 256, and return a Python int with the same numeric value.
   If n is 0, the integer is 0.  Else:
   If little_endian is 1/true, bytes[n-1] is the MSB and bytes[0] the LSB;
   else (little_endian is 0/false) bytes[0] is the MSB and bytes[n-1] the
   LSB.
   If is_signed is 0/false, view the bytes as a non-negative integer.
   If is_signed is 1/true, view the bytes as a 2&apos;s-complement integer,
   non-negative if bit 0x80 of the MSB is clear, negative if set.
   Error returns:
   + Return NULL with the appropriate exception set if there&apos;s not
     enough memory to create the Python int.
*/</doc>
<use f='codebrowser/Modules/_io/textio.c' l='2071' u='c' c='textiowrapper_build_cookie'/>
<use f='codebrowser/Modules/_pickle.c' l='4808' u='c' c='load_counted_long'/>
<use f='codebrowser/Modules/_randommodule.c' l='426' u='c' c='random_getrandbits'/>
<use f='codebrowser/Modules/arraymodule.c' l='2133' u='c' c='array__array_reconstructor_impl'/>
<def f='codebrowser/Objects/longobject.c' l='773' ll='882' type='PyObject * _PyLong_FromByteArray(const unsigned char * bytes, size_t n, int little_endian, int is_signed)'/>
<use f='codebrowser/Objects/longobject.c' l='5294' u='c' c='int_from_bytes_impl'/>
